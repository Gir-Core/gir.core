using System;
using System.Runtime.InteropServices;

#nullable enable

{{~ $record_name = get_metadata "Name" ~}}
{{~ $safe_handle = "Native." + get_metadata "SafeHandleRefName" ~}}

namespace {{ namespace.name }}
{
    // AUTOGENERATED FILE - DO NOT MODIFY
    public partial class {{ $record_name }} : GLib.IHandle
    {
        private readonly {{ $safe_handle }} _handle;
        
        public {{ $safe_handle }} Handle => !_handle.IsInvalid ? _handle : throw new Exception("Invalid Handle");
        
        // TODO: Having these both called Handle is confusing - rename?
        IntPtr GLib.IHandle.Handle => _handle.DangerousGetHandle();
        
        // Override this to perform additional steps in the constructor
        partial void Initialize();
        
        private {{ $record_name }}({{ $safe_handle }} handle)
        {
            _handle = handle;
            Initialize();
        }
        
        public static {{ $record_name }} __FactoryNew({{ $safe_handle }} handle)
            => new {{ $record_name }}(handle);
            
        public static {{ $record_name }} __FactoryNew(IntPtr ptr)
            => new {{ $record_name }}(new {{ $safe_handle }}(ptr));
        
        // TODO: Default Constructor (allocate in managed memory and free on Dispose?)
        // We need to be able to create instances of records with full access to
        // fields, e.g. Gdk.Rectangle, Gtk.TreeIter, etc. 
        
        // TODO: Implement IDispose and free safe handle
    }
}